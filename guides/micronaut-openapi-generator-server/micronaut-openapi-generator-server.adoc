common:header-top.adoc[]

== Getting Started

In this guide we will write an OpenAPI definition file and then use it to generate a Java Micronaut server API.
Then we will add internal logic to the API and test our implementation.

common:requirements.adoc[]

common:completesolution.adoc[]

== Installing OpenAPI Generator

To use https://github.com/OpenAPITools/openapi-generator[OpenAPI Generator] we need to install OpenAPI Generator CLI.

https://github.com/OpenAPITools/openapi-generator#13---download-jar[Download the JAR] and store it in the folder that you want to use for this project.

Next, open terminal in the same folder. To verify that generator works correctly run the `help` command:
[source,bash]
----
java -jar openapi-generator-cli-XXX.jar help
----

It should provide a description and a list of commands.

[NOTE]
===============================
All the options for installation are given at the https://openapi-generator.tech/docs/installation[OpenAPI Generator website].

If you installed the generator with a packet manager or bash launcher script, simply run
[source,bash]
----
openapi-generator-cli help
----
===============================

NOTE: You can also use the https://openapi-generator.tech/docs/online[OpenAPI Generator Online Service] but its usage
is not covered by this guide.


== Creating the API definition file

We will now create a definition file, that will describe our server API, including the available paths and operations on them.

//NOTE: You can get the complete version of the config file
//that we are about to create here:
//link:{sourceDir}@sourceDir@/library-definition.yaml[library-definition.yaml].
//However, we do recommend you to look through each of its sections for better understanding.

Openapi generator supports `.yaml` and `.json` file formats for the definition file.
We will use YAML due its simplicity and human readability.

In the folder to which you downloaded the OpenAPI generator CLI create a file named `library-definition.yaml` and open it with your
favourite text editor.

=== General server info

Paste the following text to the file:

resource:library-definition.yaml[tag=info]

<1> The version that will be used for parsing.
<2> The info object contains general information about the api to its reader.
<3> Tags will be used to logically structure different paths.

NOTE: If you are new to OpenAPI, you might be interested in reading the
link:https://swagger.io/docs/specification/about/[OpenAPI guide] or the
link:https://swagger.io/specification/[OpenAPI 3.0.0 specification] after you finish this guide.

=== Paths and operations definition

We will proceed by defining a path that will be available in our API. Paste the following to our file:

resource:library-definition.yaml[tags=paths|search]

<1> We define the `GET` operation on the `/search` path.
<2> We use the `books` tag that we previously defined. Note that for each tag a Controller will be generated
that will implement its operations.
<3> The `search` operation id will be used as method name for the given path.
<4> We define 2 parameters of type string that user should supply in query.
<5> Validation can be used on parameters. In this case book name must contain at least 3 characters.
<6> The `responses` object describes the response codes that can be produced.
It also defines the structure of body if any.
<7> In case of correct request we define the body to contain a list of `BookInfo` objects. The schema for the book info
object will be defined later in `components/schemas` section of definition.
<8> The `"400"` status code will be produced by Micronaut in case of bad request, like an incorrect type supplied or
failed validation. Even though Micronaut handles it automatically and no implementation is needed on our side, we add it
for a complete api specification.

NOTE: You can read more about parameter descriptions in the
link:https://swagger.io/docs/specification/describing-parameters/["Describing Parameters" OpenAPI guide].
All the available types and their validations are described in
link:https://swagger.io/docs/specification/data-models/data-types/["Data Models (Schemas)" OpenAPI guide].

We will define another path with `POST` operation similarly to the way we created the first one:

resource:library-definition.yaml[tags=paths|add]

<1> We define the `POST` method for the `/add` path, and add the same tag `books` to it.
<2> We specify that a body is required and what are the supported content-types for it.
(in this case only `application/json`, but multiple can be allowed).
<3> We write that `BookInfo` object is required to be in the request body.
We reference the same `BookInfo` schema that we will define next.

NOTE: If you want to read more about body definitions, you can read the
link:https://swagger.io/docs/specification/describing-request-body/["Describing Request Body" OpenAPI guide].

=== Schemas

We will add schemas to the definition file:

resource:library-definition.yaml[tag=components]

<1> We define the `BookInfo` schema inside then `components/schemas` section.
From this schema a java class will be generated with the same `BookInfo` classname.
<2> We define all the properties of `BookInfo`, including required validation on them. An abbreviated form is used
for some YAML lists and dictionaries to reduce the number of rows and simplify readability.
<3> We reference another scheme to be used as a property.
<4> We define `BookAvailability` scheme to be an enum with 3 available values.
A java `BookAvailability` class will be generated with given enum values based on our definition.

NOTE: You can read more about writing schemas in the
link:https://swagger.io/docs/specification/data-models/["Data Models (Schemas)" OpenAPI guide].

Save the file and proceed to the next part of the guide.
//Altogether it should look like this: link:@sourceDir@/library-definition.yaml[library-definition.yaml].

== Generating server API from template

Now we will generate server API files from our definition.
Open the terminal in the same folder as `libaray-definition.yaml` file and run the following command:

[source,bash]
----
java -jar openapi-generator-cli-XXX.jar generate \
    -g java-micronaut-server \# <1>
    -i library-definition.yaml \# <2>
    -o ./ \# <3>
    -p controllerPackage=example.micronaut.library.controller \# <4>
    -p modelPackage=example.micronaut.library.model \# <5>
    -p build=@build@ \# <6>
    -p test=junit# <7>
----
<1> Specify that we will use java Micronaut server generator.
<2> Specify our OpenAPI definition file as `library-definition.yaml` which we just created.
<3> Specify the output directory to be the current directory (`./`).
You can specify it to be a different one if you want (e.g. `library-server`).
<4> We provide generator-specific properties starting with `-p`.
We want all the controllers to be generated in the `example.micronaut.library.controller` package.
<5> We want all the models (data models, like `BookInfo`) to be in `example.micronaut.library.model` package.
<6> We want to use @build@ as build tool. The supported values are `gradle`, `maven` and `all`.
If nothing is specified, both maven and gradle files are generated.
<7> We want to use JUnit 5 for testing. The supported values are `junit` (JUnit 5) and `spock`.
If nothing is specified, `junit` is used by default.

[WARNING]
=========
If you are using Windows command prompt, run:
=========
[source,bash]
----
java -jar openapi-generator-cli-XXX.jar generate -g java-micronaut-server -i library-definition.yaml -o ./ -p controllerPackage=example.micronaut.library.controller -p modelPackage=example.micronaut.library.model -p build=@build@ -p test=junit
----

[NOTE]
=========
If you want to view all the available parameters for micronaut server generator, run
[source,bash]
----
java -jar openapi-generator-cli-XXX.jar config-help \
    -g java-micronaut-server
----
=========

[NOTE]
=========
If you plan to change the definition file and regenerate files, consider setting the `-p generateControllerAsAbstract=true`
parameter (We don't recommend doing it during this guide, though). In this case an abstract class will be generated
for the API, while all the logic needs to be implemented in a different class (that inherits the API abstract class).
This way your changes won't be overwritten by generation, but API will be updated.
=========

After running OpenAPI generator CLI should output information about generated files.
Now you can open the folder in your favorite IDE or text editor.

You should see the following folder structure:

[source,text]
----
./
├── docs
│   └── ... # <1>
├── src/
│   ├── main/
│   │   ├── java/
│   │   │   └── example/micronaut/library
│   │   │       ├── Application.java # <2>
│   │   │       ├── controller
│   │   │       │   └── BooksController.java # <3>
│   │   │       └── model
│   │   │           ├── BookAvailability.java # <4>
│   │   │           └── BookInfo.java
│   │   └── resources/
│   │       ├── application.yml # <5>
│   │       └── logback.xml
│   └── test/
│       └── java/
│           └── example/micronaut/library # <6>
│               ├── controller
│               │   └── BooksControllerTest.java
│               └── model
│                   ├── BookAvailabilityTest.java
│                   └── BookInfoTest.java
├── README.md
└── ...
----
<1> The `docs/` folder contains automatically generated markdown files with documentation about your API.
<2> The `Application.java` will start the Micronaut server with all the detected Controllers.
<3> The `BooksController.java` is generated based on paths with `books` tag. It is generated in the package we specified
for controllers earlier.
<4> 2 files are generated in the `models/` folder based on schemas we provided in the definition.
<5> Config file for Micronaut is generated with a default value for server port and other parameters.
<6> Tests are generated for all the controllers and models.

== Writing the Controller Logic

If you look inside the generated `BookInfo.java` file, you can see the class that was generated with all the parameters
based on our definition. Notice that the constructor signature has 2 parameters, which were defined as `required` in the
YAML definition file:

[source,java]
----
    public BookInfo(String name, BookAvailability availability);
----

Along with that it has getters and setters for parameters and jackson serialization annotation.

To add the required functionality to the server we will first create a service to manage books in our library.
Create file `src/main/java/example/micronaut/library/BookService.java` with the following content:

source:library/BookService[]
callout:singleton[1]

Now open the `BooksController.java`. The class `BooksController` should have 2 methods named the same
as the operations we created in the definition file. The method have Micronaut framework annotations describing the
required API. We will now write their bodies.

First, import and inject a `BookService` instance as a class attribute:
source:library/controller/BooksController[tag=import]
source:library/controller/BooksController[tag=inject,indent=0]
<1> Micronaut will create an instance of the class and inject it here.

Next, we will add an implementation of the `search` method:

source:library/controller/BooksController[tag=search,indent=0]
<1> Return a Reactor publisher, that will return the result of search method.

And finally, we will implement the `addBook` method:
source:library/controller/BooksController[tag=addBook,indent=0]
<1> Call the desired function and return empty string, that to send an empty body in response.


common:runapp.adoc[]

You can send a few requests to the paths to test the application. As an example, we will use cURL for that:

[source,bash]
----
curl localhost:8080/search?book-name=Guide
----
[source,bash]
----
[{"name":"The Hitchhiker's Guide to the Galaxy","availability":"reserved","author":"Douglas Adams"},
{"name":"Java Guide for Beginners","availability":"available"}]
----
[source,bash]
----
curl -i localhost:8080/search?book-name=Gu
----
[source,bash]
----
TP/1.1 400 Bad Request
Content-Type: application/json
date: ****
content-length: 180
connection: keep-alive

{"message":"Bad Request","_embedded":{"errors":[{"message":"bookName: size must be between 3 and 2147483647"}]},
"_links":{"self":{"href":"/search?book-name=Gu","templated":false}}}
----
[source,bash]
----
curl -i -d '{"name": "My book", "availability": "available"}' \
  -H 'Content-Type: application/json' -X POST localhost:8080/add
----
[source,bash]
----
TP/1.1 200 OK
date: Tue, 1 Feb 2022 00:01:57 GMT
Content-Type: application/json
content-length: 0
connection: keep-alive
----

== Testing Application

As we have noticed previously, some files were generated as templates for tests.

We will modify the `src/test/java/example/micronaut/library/controllerBooksControllerTest` to test our paths.
For path `/search` 2 methods were generated: one for testing the `search` method itself, and another for testing
the API from the point of a client.

We will delete the `searchMethodTest()` and modify the `searchClientApiTest()` method to perform a basic check.
All the modifications compared to the generated version are labeled here:

test:library/controller/BooksControllerTest[tag=search,indent=0]
<1> Remove the `@Disabled` annotation, so that the test would run.
<2> Specify the value of query the parameter.
<3> Store the response body in a variable.
<4> Add assertion: we expect to get 2 books containing `"Guide"` as response.

We will also add a test to the `/add` path:
test:library/controller/BooksControllerTest[tag=addBook,indent=0]
<1> Remove the `@Disabled` annotation, so that the test would run.
<2> Change the fields of `BookInfo body` object.

common:testApp-noheader.adoc[]

The tests should both run successfully.

common:graal-with-plugins.adoc[]

== Next steps

=== Add Security

We could have defined our security requirements by adding a security scheme to the `library-definition.yaml` file.
For example, we will add basic authentication:

[source,yaml]
----
paths:
  /search:
    # ... #
  /add:
    post:
      # ... #
      security:
        - MyBasicAuth: [] # <2>
components:
  schemas:
    # ... #
  securitySchemes:
    MyBasicAuth: # <1>
      type: http
      scheme: basic
----
<1> Define a security scheme inside the `components/securitySchemes`. We want to use basic auth for authentication.
<2> Add the scheme to the paths that you want to secure. In this case we want to restrict access to
adding books into our library.

NOTE: You can read more about describing various authentication in the
link:https://swagger.io/docs/specification/authentication/["Authentication and Authorization" OpenAPI guide].

The generator will then annotate such endpoints with Micronaut`s
link:https://micronaut-projects.github.io/micronaut-security/latest/guide/#secured[Secured] annotation accordingly:

[source,java]
----
@Secured(SecurityRule.IS_AUTHENTICATED)
public Mono<Object> addBook( /* ... */ ){ /* ... */ }
----

You will then need to implement an
link:https://micronaut-projects.github.io/micronaut-security/latest/guide/#authenticationProviders[AuthenticationProvider]
that satisfies your needs. If you want to finish implementing the basic authentication, continue to the
link:https://guides.micronaut.io/latest/micronaut-security-basicauth.html[Micronaut Basic Auth guide] and replicate
steps to create the `AuthenticationProvider` and appropriate tests.

NOTE: You can also read link:https://micronaut-projects.github.io/micronaut-security/latest/guide/[Micronaut Security documentation]
or link:https://micronaut.io/guides[Micronaut guides] about security to learn more about all
the supported Authorization strategies.

=== Generate Micronaut Client

You can generate Micronaut Client based on the same `library-definition.yaml` file.

Run the following in terminal to create client in the `library-client` folder:

[source,bash]
----
java -jar openapi-generator-cli-XXXXXX.jar generate \
    -g java-micronaut-client \
    -i library-definition.yaml \
    -o library-client \
    -p apiPackage=example.micronaut.library.api \
    -p modelPackage=example.micronaut.library.model \
    -p build=@build@ \
    -p test=junit
----

=== Learn Micronaut

To learn more about Micronaut framework and its features visit
link:https://micronaut.io/docs/[Micronaut documentation].

=== Generate User-Friendly Documentation

You can generate documentation in html file inside the `html-docs/` folder by running
[source,bash]
----
java -jar openapi-generator-cli-XXX.jar generate \
    -g html2 \
    -i library-definition.yaml \
    -o html-docs
----

common:helpWithMicronaut.adoc[]
